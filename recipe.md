```sql
CREATE TABLE tab_group (
  id bigint generated by DEFAULT AS identity PRIMARY key, 
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, 
  tab_name VARCHAR(30) NOT NULL, 
  is_default BOOLEAN DEFAULT FALSE,
  CONSTRAINT unique_user_group_name UNIQUE (user_id, tab_name) 
);

CREATE TABLE tabs (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id), 
  tab_group_id INTEGER REFERENCES tab_group(id) ON DELETE SET NULL,
  inserted_at TIMESTAMP WITH time zone default timezone('utc'::text, now()) not null,
  updated_at TIMESTAMP WITH time zone default timezone('utc'::text, now()) not null,
  position INTEGER,
  url TEXT NOT NULL,
  parsed_url TEXT,
  description VARCHAR(255),
  favicon_url TEXT
);

ALTER TABLE tabs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow user to select own tabs" ON tabs
FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Allow user to insert their own tabs" ON tabs
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Allow user to update their own tabs" ON tabs
FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Allow user to delete their own tabs" ON tabs
FOR DELETE
USING (auth.uid() = user_id);

ALTER TABLE tab_group ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow user to select own tab group" ON tab_group
FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Allow user to insert their own tab group" ON tab_group
FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Allow user to update their own tab group" ON tab_group
FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Allow user to delete their own tab group" ON tab_group
FOR DELETE
USING (auth.uid() = user_id);
```

## 1. Extract nouns from the user stories or specification

```

As a user,
So I can omit distractions,
I want to move distracting tabs to a list in the sidebar to be read later.

As a user,
I should only be able to see my saved tabs

As a user,
So I can view my tabs later,
I want to store the name, url, description, favicon, timestamp.

As a user,
So I can organise my tabs,
I want to change the tabs position in the list if needed.

As a user,
So I can organise my tabs,
I want to store tabs in groups if needed.

As a user,
So I can organise my tabs,
I want to set a default group.


```

```
Nouns:

tabs, name, url, description, favicon, timestamp, position, group
```

## 2. Infer the Table Name and Columns

Put the different nouns in this table. 

| Tabs                | Properties          |
| --------------------- | ------------------  |
| user               | id, first_name, last_name, email
| tab_group          | id, name, user_id, is_default
| tab                | id, name, description, url, favicon, inserted_time, position, group

1. Name of the first table (always plural): `users` 

    Column names: `user_id`, `first_name`, `last_name`, `email`, `registered_date`

2. Name of the second table (always plural): `tab_groups` 

    Column names: `id`, `owner`, `name`, `is_default`

3. Name of the third table (always plural): `tabs` 

    Column names: `id`, `owner`, `name`, `is_default`

## 3. Decide the column types

[Here's a full documentation of PostgreSQL data types](https://www.postgresql.org/docs/current/datatype.html).

Most of the time, you'll need either `text`, `int`, `bigint`, `numeric`, or `boolean`. If you're in doubt, do some research or ask your peers.

Remember to **always** have the primary key `id` as a first column. Its type will always be `SERIAL`.

```
# EXAMPLE:

Table: albums
id: SERIAL
title: text
release_year: int

Table: artists
id: SERIAL
name: text
```

## 4. Decide on The Tables Relationship

Most of the time, you'll be using a **one-to-many** relationship, and will need a **foreign key** on one of the two tables.

To decide on which one, answer these two questions:

1. Can one [TABLE ONE] have many [TABLE TWO]? (Yes/No)
2. Can one [TABLE TWO] have many [TABLE ONE]? (Yes/No)

You'll then be able to say that:

1. **[A] has many [B]**
2. And on the other side, **[B] belongs to [A]**
3. In that case, the foreign key is in the table [B]

Replace the relevant bits in this example with your own:

```
# EXAMPLE

1. Can one artist have many albums? YES
2. Can one album have many artists? NO

-> Therefore,
-> An artist HAS MANY albums
-> An album BELONGS TO an artist

-> Therefore, the foreign key is on the albums table.
```

*If you can answer YES to the two questions, you'll probably have to implement a Many-to-Many relationship, which is more complex and needs a third table (called a join table).*

## 5. Write the SQL

```sql
-- EXAMPLE
-- file: albums_table.sql

-- Replace the table name, columm names and types.

-- Create the table without the foreign key first.
CREATE TABLE artists (
  id SERIAL PRIMARY KEY,
  name text,
);

-- Then the table with the foreign key second.
CREATE TABLE albums (
  id SERIAL PRIMARY KEY,
  title text,
  release_year int,
-- The foreign key name is always {other_table_singular}_id
  artist_id int,
  constraint fk_artist foreign key(artist_id)
    references artists(id)
    on delete cascade
);

```

## 6. Create the tables

```bash
psql -h 127.0.0.1 database_name < albums_table.sql
```